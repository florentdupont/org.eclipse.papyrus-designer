// --------------------------------------------------------
// Code generated by Papyrus C++
// --------------------------------------------------------

#ifndef SIMPLESM_CLASSES_SIMPLESM_H
#define SIMPLESM_CLASSES_SIMPLESM_H

/************************************************************
 SimpleSM class header
 ************************************************************/

#include "SimpleSM/classes/Pkg_classes.h"

#include "AnsiCLibrary/Pkg_AnsiCLibrary.h"
#include "PrimitiveTypes/Pkg_PrimitiveTypes.h"
#include "pthread.h"
#include "statemachine/EventPriorityQueue.h"
#include "statemachine/Pkg_statemachine.h"
#include "statemachine/StructForThread_t.h"
#include "sysinterfaces/IStart.h"

// Include from Include stereotype (header)
#define SIMPLESM_TIME_EVENT_LOWER_BOUND (0)
#define SIMPLESM_CHANGE_EVENT_LOWER_BOUND (2)
#define SIMPLESM_TE_INDEX(id) (id - SIMPLESM_TIME_EVENT_LOWER_BOUND)
#define SIMPLESM_CHE_INDEX(id) (id - SIMPLESM_CHANGE_EVENT_LOWER_BOUND)
#define SMSIMPLE_REGION0_DEFAULT (0)
#define SMSIMPLE_REGION0 (0)
#include "time.h"
#include "pthread.h"
#include "time.h"
#include "sys/time.h"
#define CHECKPOINT if (systemState == statemachine::EVENT_PROCESSING) {return;}
#define SimpleSM_THREAD_CREATE(thThread, str) pthread_create(&thThread, NULL, &SimpleSM::thread_func_wrapper, &str);
#define SIMPLESM_GET_CONTROL /*mutex synchronization to protect run-to-completion semantics*/ \
		pthread_mutex_lock(&runToCompletionMutex); \
		while (systemState != statemachine::IDLE) {\
			pthread_cond_wait(&runToCompletionCond, &runToCompletionMutex);\
		}
#define SIMPLESM_RELEASE_CONTROL systemState = statemachine::IDLE; pthread_cond_signal(&runToCompletionCond); \
				pthread_mutex_unlock(&runToCompletionMutex);
// End of Include stereotype (header)

namespace statemachine {
class Event_t;
}

namespace SimpleSM {
namespace classes {

/************************************************************/
/**
 * State-machine support is enabled with a container rule
 */
class SimpleSM: public ::sysinterfaces::IStart {
public:
	/**
	 * 
	 */
	typedef struct State_t {
		//1 is configured as the maximum number of orthogonal regions a composite states can have
		unsigned int /*StateIDEnum*/previousStates[1]; //for history states
		unsigned int /*StateIDEnum*/actives[1];
		void (SimpleSM::*entry)();
		void (SimpleSM::*exit)();
		void (SimpleSM::*doActivity)();
		State_t() {
			entry = &SimpleSM::entry_dft;
			exit = &SimpleSM::exit_dft;
			doActivity = &SimpleSM::doActivity_dft;
			for (int i = 0; i < 1; i++) {
				previousStates[i] = STATE_MAX;
				actives[i] = STATE_MAX;
			}
		}
	} State_t;

	/**
	 * 
	 */
	enum StateIDEnum {
		/**
		 * 
		 */
		FLIP_ID,
		/**
		 * 
		 */
		FLOP_ID,
		/**
		 * 
		 */
		STATE_MAX
	};
	/**
	 * 
	 */
	typedef void (SimpleSM::*FptPointer)();

	/**
	 * 
	 */
	enum EventId_t {
		/**
		 * 
		 */
		TE_VALUE_250_UNIT_MS__ID,
		/**
		 * 
		 */
		TE_VALUE_500_UNIT_MS__ID,
		/**
		 * 
		 */
		CE_CSERVER_IMPL_ADD_ID,
		/**
		 * 
		 */
		COMPLETIONEVENT_ID
	};
	/**
	 * 
	 */
	::statemachine::SystemStateEnum_t systemState;
	/**
	 * 
	 */
	::SimpleSM::classes::SimpleSM::State_t states[2];
	/**
	 * 
	 */
	::SimpleSM::classes::SimpleSM::StateIDEnum activeStateID;
	/**
	 * 
	 */
	bool dispatchFlag;
	/**
	 * 
	 */
	pthread_t threads[STATE_MAX];
	/**
	 * 
	 */
	bool flags[STATE_MAX];
	/**
	 * 
	 */
	pthread_cond_t conds[STATE_MAX];
	/**
	 * 
	 */
	pthread_mutex_t mutexes[STATE_MAX];
	/**
	 * 
	 */
	::statemachine::StructForThread_t threadStructs[STATE_MAX];
	/**
	 * 
	 */
	::SimpleSM::classes::SimpleSM::FptPointer doActivityTable[STATE_MAX];
	/**
	 * 
	 */
	::SimpleSM::classes::SimpleSM::FptPointer timeEventTable[2];
	/**
	 * 
	 */
	pthread_t timeEventThreads[2];
	/**
	 * 
	 */
	bool timeEventFlags[2];
	/**
	 * 
	 */
	pthread_cond_t timeEventConds[2];
	/**
	 * 
	 */
	pthread_mutex_t timeEventMutexes[2];
	/**
	 * 
	 */
	::statemachine::StructForThread_t timeEventThreadStructs[2];
	/**
	 * 
	 */
	::statemachine::EventPriorityQueue eventQueue;
	/**
	 * 
	 */
	::statemachine::Event_t* currentEvent;
	/**
	 * 
	 */
	pthread_t dispatchThread;
	/**
	 * 
	 */
	::statemachine::StructForThread_t dispatchStruct;
	/**
	 * 
	 */
	pthread_mutex_t runToCompletionMutex;
	/**
	 * 
	 */
	pthread_cond_t runToCompletionCond;

	/**
	 * 
	 */
	void dispatchEvent();

	/**
	 * 
	 * @param a 
	 * @param b 
	 * @return res 
	 */
	::PrimitiveTypes::Integer add(::PrimitiveTypes::Integer /*in*/a,
			::PrimitiveTypes::Integer /*in*/b);

	/**
	 * 
	 */
	void run();

	/**
	 * 
	 * @param enter_mode 
	 */
	void SMSimple_Region0_Enter(char /*in*/enter_mode);

	/**
	 * 
	 */
	SimpleSM();

	/**
	 * 
	 */
	void startBehavior();

	/**
	 * 
	 * @param a 
	 * @param b 
	 */
	void processCE_CServer_impl_add(::PrimitiveTypes::Integer /*in*/a,
			::PrimitiveTypes::Integer /*in*/b);

	/**
	 * 
	 */
	void processTE_value_250_unit_ms_();

	/**
	 * 
	 */
	void processTE_value_500_unit_ms_();

	/**
	 * 
	 */
	void processCompletionEvent();

	/**
	 * 
	 * @param data 
	 * @return ret 
	 */
	static void* thread_func_wrapper(void* /*in*/data);

	/**
	 * 
	 * @param id 
	 */
	void doCallActivity(int /*in*/id);

	/**
	 * 
	 * @param id 
	 * @param func_type 
	 * @param value 
	 */
	void setFlag(int /*in*/id, char /*in*/func_type, bool /*in*/value);

	/**
	 * 
	 * @param id 
	 * @param duration 
	 */
	void listenTimeEvent(int /*in*/id, int /*in*/duration);

	/**
	 * 
	 */
	void entry_dft();

	/**
	 * 
	 */
	void exit_dft();

	/**
	 * 
	 */
	void doActivity_dft();

};
/************************************************************/
/* External declarations (package visibility)               */
/************************************************************/

/* Inline functions                                         */

} // of namespace classes
} // of namespace SimpleSM

/************************************************************
 End of SimpleSM class header
 ************************************************************/

#endif
