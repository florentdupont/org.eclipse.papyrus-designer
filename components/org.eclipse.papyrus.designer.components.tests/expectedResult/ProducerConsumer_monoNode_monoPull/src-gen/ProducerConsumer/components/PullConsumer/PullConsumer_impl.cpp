// --------------------------------------------------------
// Code generated by Papyrus C++
// --------------------------------------------------------

#define ProducerConsumer_components_PullConsumer_PullConsumer_impl_BODY

/************************************************************
 PullConsumer_impl class body
 ************************************************************/

// include associated header file
#include "ProducerConsumer/components/PullConsumer/PullConsumer_impl.h"

// Derived includes directives
#include "ProducerConsumer/components/interfaces/PubData.h"
#include "ProducerConsumer/derivedTypes/ProducerConsumer/components/interfaces/PullConsumer_PubData.h"
#include "sysinterfaces/IRunnable.h"

// Include from Include declaration (body)
#include <unistd.h>
#include <iostream>
using namespace std;
// End of Include declaration (body)

namespace ProducerConsumer {
namespace components {
namespace PullConsumer {

// static attributes (if any)

/**
 * 
 */
void PullConsumer_impl::run() {
	cout << "wait for data on port p" << endl;
	for (int i = 0; i < 25; i++) {
		if (p->hasData()) {
			components::interfaces::PubData data = p->pull();
			cout << "received data: x = " << data.x << " y = " << data.y
					<< endl;
		}
		usleep(100 * 1000);
	}
	cout << "finished waiting" << endl;
}

/**
 * 
 * @return ret 
 */
::sysinterfaces::IRunnable* PullConsumer_impl::get_run() {
	return this;
}

/**
 * 
 * @param ref 
 */
void PullConsumer_impl::connect_p(
		::ProducerConsumer::derivedTypes::ProducerConsumer::components::interfaces::PullConsumer_PubData* /*in*/ref) {
	p = ref;
}

// opaque behavior without specification (typically from state machine)
/**
 * 
 * 
 */
void PullConsumer_impl::configuration_complete() {
}

} // of namespace PullConsumer
} // of namespace components
} // of namespace ProducerConsumer

/************************************************************
 End of PullConsumer_impl class body
 ************************************************************/
