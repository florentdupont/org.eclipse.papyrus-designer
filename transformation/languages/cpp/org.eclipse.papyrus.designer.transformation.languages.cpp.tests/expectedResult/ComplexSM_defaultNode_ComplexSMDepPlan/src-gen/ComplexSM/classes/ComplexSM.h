// --------------------------------------------------------
// Code generated by Papyrus C++
// --------------------------------------------------------

#ifndef COMPLEXSM_CLASSES_COMPLEXSM_H
#define COMPLEXSM_CLASSES_COMPLEXSM_H

/************************************************************
 ComplexSM class header
 ************************************************************/

#include "ComplexSM/classes/Pkg_classes.h"

#include "AnsiCLibrary/Pkg_AnsiCLibrary.h"
#include "ComplexSM/classes/Interfaces/ICompute.h"
#include "pthread.h"
#include "statemachine/EventPriorityQueue.h"
#include "statemachine/Pkg_statemachine.h"
#include "statemachine/StructForThread_t.h"
#include "sysinterfaces/IStart.h"

// Include from Include stereotype (header)
#define COMPLEXSM_TIME_EVENT_LOWER_BOUND (0)
#define COMPLEXSM_CHANGE_EVENT_LOWER_BOUND (3)
#define COMPLEXSM_TE_INDEX(id) (id - COMPLEXSM_TIME_EVENT_LOWER_BOUND)
#define COMPLEXSM_CHE_INDEX(id) (id - COMPLEXSM_CHANGE_EVENT_LOWER_BOUND)
#define SMSIMPLE_REGION0_DEFAULT (0)
#define SMSIMPLE_REGION0_STATE1 (1)
#define STATE3_REGION1_SHALLOWHISTORY1 (1)
#define SMSIMPLE_REGION0 (0)
#define STATE3_REGION1 (1)
#include "time.h"
#include "pthread.h"
#include "time.h"
#include "sys/time.h"
#define CHECKPOINT if (systemState == statemachine::EVENT_PROCESSING) {return;}
#define ComplexSM_THREAD_CREATE(thThread, str) pthread_create(&thThread, NULL, &ComplexSM::thread_func_wrapper, &str);
#define COMPLEXSM_GET_CONTROL /*mutex synchronization to protect run-to-completion semantics*/ \
		pthread_mutex_lock(&runToCompletionMutex); \
		while (systemState != statemachine::IDLE) {\
			pthread_cond_wait(&runToCompletionCond, &runToCompletionMutex);\
		}
#define COMPLEXSM_RELEASE_CONTROL systemState = statemachine::IDLE; pthread_cond_signal(&runToCompletionCond); \
				pthread_mutex_unlock(&runToCompletionMutex);
// End of Include stereotype (header)

namespace statemachine {
class Event_t;
}

namespace ComplexSM {
namespace classes {

/************************************************************/
/**
 * 
 */
class ComplexSM: public ::ComplexSM::classes::Interfaces::ICompute,
		public ::sysinterfaces::IStart {
public:
	/**
	 * 
	 */
	typedef struct State_t {
		//1 is configured as the maximum number of orthogonal regions a composite states can have
		unsigned int /*StateIDEnum*/previousStates[1]; //for history states
		unsigned int /*StateIDEnum*/actives[1];
		void (ComplexSM::*entry)();
		void (ComplexSM::*exit)();
		void (ComplexSM::*doActivity)();
		State_t() {
			entry = &ComplexSM::entry_dft;
			exit = &ComplexSM::exit_dft;
			doActivity = &ComplexSM::doActivity_dft;
			for (int i = 0; i < 1; i++) {
				previousStates[i] = STATE_MAX;
				actives[i] = STATE_MAX;
			}
		}
	} State_t;

	/**
	 * 
	 */
	enum StateIDEnum {
		/**
		 * 
		 */
		STATE0_ID,
		/**
		 * 
		 */
		STATE1_ID,
		/**
		 * 
		 */
		STATE2_ID,
		/**
		 * 
		 */
		STATE3_ID,
		/**
		 * 
		 */
		STATE3_1_ID,
		/**
		 * 
		 */
		STATE3_2_ID,
		/**
		 * 
		 */
		STATE_MAX
	};
	/**
	 * 
	 */
	typedef void (ComplexSM::*FptPointer)();

	/**
	 * 
	 */
	enum EventId_t {
		/**
		 * 
		 */
		TE_VALUE_50_UNIT_MS__ID,
		/**
		 * 
		 */
		TE_VALUE_500_UNIT_MS__ID,
		/**
		 * 
		 */
		TE_VALUE_25_UNIT_MS__ID,
		/**
		 * 
		 */
		CE_CSERVER_IMPL_ADD_ID,
		/**
		 * 
		 */
		COMPLETIONEVENT_ID
	};
	/**
	 * 
	 */
	int x;
	/**
	 * 
	 */
	::statemachine::SystemStateEnum_t systemState;
	/**
	 * 
	 */
	int Junction1;
	/**
	 * 
	 */
	::ComplexSM::classes::ComplexSM::State_t states[6];
	/**
	 * 
	 */
	::ComplexSM::classes::ComplexSM::StateIDEnum activeStateID;
	/**
	 * 
	 */
	bool dispatchFlag;
	/**
	 * 
	 */
	pthread_t threads[STATE_MAX];
	/**
	 * 
	 */
	bool flags[STATE_MAX];
	/**
	 * 
	 */
	pthread_cond_t conds[STATE_MAX];
	/**
	 * 
	 */
	pthread_mutex_t mutexes[STATE_MAX];
	/**
	 * 
	 */
	::statemachine::StructForThread_t threadStructs[STATE_MAX];
	/**
	 * 
	 */
	::ComplexSM::classes::ComplexSM::FptPointer doActivityTable[STATE_MAX];
	/**
	 * 
	 */
	::ComplexSM::classes::ComplexSM::FptPointer timeEventTable[3];
	/**
	 * 
	 */
	pthread_t timeEventThreads[3];
	/**
	 * 
	 */
	bool timeEventFlags[3];
	/**
	 * 
	 */
	pthread_cond_t timeEventConds[3];
	/**
	 * 
	 */
	pthread_mutex_t timeEventMutexes[3];
	/**
	 * 
	 */
	::statemachine::StructForThread_t timeEventThreadStructs[3];
	/**
	 * 
	 */
	::statemachine::EventPriorityQueue eventQueue;
	/**
	 * 
	 */
	::statemachine::Event_t* currentEvent;
	/**
	 * 
	 */
	pthread_t dispatchThread;
	/**
	 * 
	 */
	::statemachine::StructForThread_t dispatchStruct;
	/**
	 * 
	 */
	pthread_mutex_t runToCompletionMutex;
	/**
	 * 
	 */
	pthread_cond_t runToCompletionCond;

	/**
	 * 
	 */
	void dispatchEvent();

	/**
	 * 
	 * @param a 
	 * @param b 
	 * @return res 
	 */
	long add(long /*in*/a, long /*in*/b);

	/**
	 * 
	 * @param a 
	 * @param b 
	 * @return res 
	 */
	long mult(long /*in*/a, long /*in*/b);

	/**
	 * 
	 */
	void run();

	/**
	 * 
	 * @param enter_mode 
	 */
	void SMSimple_Region0_Enter(char /*in*/enter_mode);

	/**
	 * 
	 * @param enter_mode 
	 */
	void State3_Region1_Enter(char /*in*/enter_mode);

	/**
	 * 
	 */
	void State3_Region1_Exit();

	/**
	 * 
	 */
	ComplexSM();

	/**
	 * 
	 */
	void startBehavior();

	/**
	 * 
	 */
	void processTE_value_50_unit_ms_();

	/**
	 * 
	 */
	void processTE_value_500_unit_ms_();

	/**
	 * 
	 * @param a 
	 * @param b 
	 */
	void processCE_CServer_impl_add(long /*in*/a, long /*in*/b);

	/**
	 * 
	 */
	void processTE_value_25_unit_ms_();

	/**
	 * 
	 */
	void processCompletionEvent();

	/**
	 * 
	 */
	void State2_entry();

	/**
	 * 
	 * @param data 
	 * @return ret 
	 */
	static void* thread_func_wrapper(void* /*in*/data);

	/**
	 * 
	 * @param id 
	 */
	void doCallActivity(int /*in*/id);

	/**
	 * 
	 * @param id 
	 * @param func_type 
	 * @param value 
	 */
	void setFlag(int /*in*/id, char /*in*/func_type, bool /*in*/value);

	/**
	 * 
	 * @param id 
	 * @param duration 
	 */
	void listenTimeEvent(int /*in*/id, int /*in*/duration);

	/**
	 * 
	 */
	void entry_dft();

	/**
	 * 
	 */
	void exit_dft();

	/**
	 * 
	 */
	void doActivity_dft();

};
/************************************************************/
/* External declarations (package visibility)               */
/************************************************************/

/* Inline functions                                         */

} // of namespace classes
} // of namespace ComplexSM

/************************************************************
 End of ComplexSM class header
 ************************************************************/

#endif
